# -*- coding: utf-8 -*-
"""QCG hackathon

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1liHhj8UupQXfFD9_0Hnis0ldJQJuxFBT
"""

# Commented out IPython magic to ensure Python compatibility.
!pip install pylatexenc 
import tensorflow as tf
import pylatexenc
# %matplotlib inline

!pip install qiskit
import qiskit
import numpy as py

#LSTM FUNCTION
def LSTM(x):
  a1=len(x)
  wxi=1 
  wxg=1 
  bi=1 
  whj=1
  whg=1
  whi=1
  bg=1
  wxf, bf, whf=1,1,1
  wxo, bo, who=1,1,1
  h,c=0,0
  q=list()
  output_array=[]
  output_array.append(h)
  for i in range(0,a1):
      string=x[i]
      result=' '.join(format(ord(i),'b') for i in string)
      c=int(result)
      q.append(c)
  for i in range(0,a1):
    #Input Gate
    p=q[i]
    Zg = wxg *p + whg * h + bg 
    g = py.tanh(Zg)
    Zi = wxi * p + whi * h + bi 
    i =  1/(1 + py.exp(-Zi)) 
    input_gate_out=g*i
    #Forget Gate
    Zf = wxf * p + whf *h + bf 
    f =  1/(1 + py.exp(-Zf)) 
    forget_gate_out = f

    #OutPut gate
    Zo  = wxo*p +  who * h + bo 
    o =  1/(1 + py.exp(-Zo)) 
    out_gate_out = o 

    #calculation
    c = (c * forget_gate_out) + input_gate_out 
    h=out_gate_out * (py.tanh(c))

  return h

#Activation Function 
def circuit1(x,theta):
  r=int(x)
  q=qiskit.QuantumRegister(r,'q')
  c=qiskit.ClassicalRegister(1,'c')
  circuit=qiskit.QuantumCircuit(q,c)
  for i in range(0,r):
    circuit.rz(theta[i],q[i])
    circuit.h(q[i])
  backend=qiskit.Aer.get_backend('qasm_simulator')
  simulator=qiskit.Aer.get_backend('statevector_simulator')
  result=qiskit.execute(circuit,backend=simulator).result()
  unitary=result.get_statevector()
  sum=0
  for i in range(0,r):
    sum=sum+((unitary[i].real)**2+(unitary[i].imag)**2)**(0.5)
  return sum

#Activation Function
def circuit2(x,theta):
  a=int(x)+1
  q=qiskit.QuantumRegister(a,'q')
  c=qiskit.ClassicalRegister(1,'c')
  circuit=qiskit.QuantumCircuit(q,c)
  for i in range(0,a):
    circuit.rz(theta[i],q[i])
    circuit.h(q[i])
  circuit.measure(q,c)
  backend=qiskit.Aer.get_backend('qasm_simulator')
  simulator=qiskit.Aer.get_backend('statevector_simulator')
  result=qiskit.execute(circuit,backend=simulator).result()
  unitary=result.get_statevector()
  ret=[0,0]
  for i in range(0,1):
    ret[i]=((unitary[i].real)**2+(unitary[i].imag)**2)**(0.5)
  return ret

#CLASSIFIER CELL
def classifier(x):
      probability=[]
      a=len(x)
      c=[]
      sum=0
      for i in range(0,a):
        c.append(py.exp(x[i]))
        sum=sum+py.exp(x[i])
      for i in range(0,a):
        probability.append(c[i]/sum)
      return probability

#Prediction cell
def output(x):
    max=0
    a=len(x)
    c=0
    for i in range(0,a):
      if x[i]>=max:
        max=x[i]
        c=i

    return c

import pandas as pd

#Training Model
csvFile = pd.read_csv('Database Ciphers.csv')
x=list()
y=list()
for i in range(0,38):
    c=csvFile.iloc[i][0]
    d=csvFile.iloc[i][1]
    x.append(c)
    y.append(d)
a=38
theta=list()
for i in range(0,a):
  theta.append(3.14/2)
while(a-1):
  result=x[a-1]
  c1=LSTM(result)
  c2=circuit1(c1,theta)
  c3=circuit2(c2,theta)
  c4=classifier(c3)
  c5=output(c4)
  if(int(y[a-1])==c5):
      continue
  else:
    for i in range(0,a):
      theta[i]=theta[i]+0.5
  a=a-1

#test
correct=0
test_set=pd.read_csv('cipher tc.csv')
l1=9
x=list()
y=list()
for i in range(0,l1):
    x.append(test_set.iloc[i][0])
    y.append(test_set.iloc[i][1])
while(l1):
  result=x[l1-1]
  c1=LSTM(result)
  c2=circuit1(c1,theta)
  c3=circuit2(c2,theta)
  c4=classifier(c3)
  c5=output(c4)
  if(int(y[1-1])==c5):
    correct=correct+1
  
  l1=l1-1
  print(c5)
print(correct)