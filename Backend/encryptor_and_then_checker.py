# -*- coding: utf-8 -*-
"""Encryptor and then Checker.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HadiiCVUP--PIPb95eTQocbW4iO4NAYi

### ***BB84 Protocol***
"""

!pip install qiskit

from qiskit import *
from qiskit.visualization import plot_histogram, plot_bloch_multivector
from numpy.random import randint
import numpy as np

# string=input("Hello")
string=input("Enter your message ")

result=' '.join(format(ord(i),'b') for i in string)
# print(result)

sender_bit=''.join(format(ord(i),'b') for i in string)
# print(sender_bit)
lgth=len(sender_bit)

#Sender Bases
np.random.seed(seed=999)
sender_bases=randint(2,size=lgth)
# print(sender_bases)

def encode_message(bits,bases):
  message=[]
  for i in range(lgth):
    qc=QuantumCircuit(1,1)
    if bases[i]==0:
      if bits[i]==0:
        pass
      else:
          qc.x(0)
    else:
      if bits[i]==0:
        qc.h(0)
      else:
        qc.x(0)
        qc.h(0)
    qc.barrier()
    message.append(qc)
  return message

def measure_message(message,bases):
  backend=Aer.get_backend('aer_simulator')
  measurements=[]
  for q in range(lgth):
    if bases[q]==0:
      message[q].measure(0,0)
    if bases[q]==1:
      message[q].h(0)
      message[q].measure(0,0)
    aer_sim=Aer.get_backend('aer_simulator')
    qobj=assemble(message[q],shots=1, memory=True)
    result=aer_sim.run(qobj).result()
    measured_bit=int(result.get_memory()[0])
    measurements.append(measured_bit)
  return measurements

def remove_garbage(a_bases,b_bases, bits):
  good_bits=[]
  for q in range(lgth):
    if a_bases[q]==b_bases[q]:
      good_bits.append(bits[q])
  return good_bits

def sample_bits(bits,selection):
  sample=[]
  for i in selection:
    i=np.mod(i,len(bits))
    sample.append(bits.pop(i))
  return sample

message=encode_message(sender_bit,sender_bases)
# message

# message[1].draw()
for i in message:
    print(i)

#Interception!
# np.random.seed(seed=999)
middleman_bases=randint(2,size=lgth)
intercepted_message=measure_message(message,middleman_bases)
# print(intercepted_message)

# message[0].draw()
for i in message:
  print(i)

np.random.seed(seed=999)
reciever_bases=randint(2,size=lgth)
reciever_results = measure_message(message,reciever_bases)
# message[0].draw()

for i in message:
  print (i)

reciever_key=remove_garbage(sender_bases,reciever_bases,reciever_results)
sender_key=remove_garbage(sender_bases,reciever_bases,sender_bit)

while(True):
  sample_size=int(input("Enter the sample size for testing interception "))
  # sample_size=15
  bit_selection=randint(lgth,size=sample_size)
  print("The probability of not finding your leaked message is " ,end='' )
  print((0.75**sample_size))
  print("Satisfied with the probability of interception checking?")
  cho=input("Enter Y for Yes and N for No ")
  if cho=='y' or cho=='Y':
    break
  else:
    continue

reciever_sample=sample_bits(reciever_key,bit_selection)
sender_sample=sample_bits(sender_key,bit_selection)

# print("Reciever_sample =   " + str(reciever_sample))
for idx in range(len(sender_sample)):
  sender_sample[idx]=int(sender_sample[idx])

# print("Sender_sample = " + str(sender_sample))

if reciever_sample!=sender_sample:
  print("Your message got leaked")
else:
  print("Relax! Your message is safe")